---

name: skill-creator
version: "1.0.0"
description: 建立有效技能的指導文件。當使用者想建立新技能（或更新現有技能），以專業知識、工作流程或工具整合來擴充 AI 的能力時，應使用此技能。
license: Complete terms in LICENSE.txt
---

# 技能建立器（Skill Creator）

此技能提供建立有效技能的指引。

## 關於技能

技能是模組化、自包含的套件，透過提供專業知識、工作流程和工具，擴充 AI 的能力。可以把它們想像成特定領域或任務的「入職指南」——它們將通用 AI 轉變為配備程序性知識的專業 AI。

### 技能提供的內容

1. 專業化工作流程——特定領域的多步驟程序
2. 工具整合——與特定檔案格式或 API 協作的說明
3. 領域專業知識——公司特定的知識、結構、業務邏輯
4. 捆綁資源——用於複雜和重複任務的腳本、參考資料和資產

## 核心原則

### 簡潔是關鍵

上下文視窗是公共資源。技能與其他所有需要的內容共用上下文視窗：系統提示、對話歷史、其他技能的後設資料，以及實際的使用者請求。

**預設假設：AI 本身已經很聰明。** 只需添加 AI 尚未具備的情境。對每條資訊提出挑戰：「AI 真的需要這個解釋嗎？」和「這段內容值得消耗這些 token 嗎？」

優先使用簡潔範例而非冗長解釋。

### 設定適當的自由度

將具體程度與任務的脆弱性和可變性相匹配：

**高自由度（文字說明）**：當多種方法都有效、決策取決於情境，或啟發式規則引導方法時使用。

**中等自由度（帶參數的虛擬碼或腳本）**：當有偏好的模式存在、某些變化是可接受的，或配置影響行為時使用。

**低自由度（具體腳本、少量參數）**：當操作容易出錯、一致性至關重要，或必須遵循特定順序時使用。

把 AI 想像成在探索路徑：有懸崖的窄橋需要具體護欄（低自由度），而開闊的平原允許多條路線（高自由度）。

### 技能結構

每個技能由一個必要的 SKILL.md 檔案和可選的捆綁資源組成：

```
skill-name/
├── SKILL.md（必要）
│   ├── YAML 前置資料後設資料（必要）
│   │   ├── name:（必要）
│   │   └── description:（必要）
│   └── Markdown 說明（必要）
└── 捆綁資源（可選）
    ├── scripts/          - 可執行程式碼（Python/Bash 等）
    ├── references/       - 依需要載入上下文的文件
    └── assets/           - 輸出中使用的檔案（範本、圖示、字體等）
```

#### SKILL.md（必要）

每個 SKILL.md 包含：

- **前置資料**（YAML）：包含 `name` 和 `description` 欄位。這是 AI 決定何時使用技能時讀取的唯一欄位，因此描述技能的內容和使用時機必須清晰完整。
- **主體**（Markdown）：使用技能的說明與指引。只在技能觸發後才載入。

#### 捆綁資源（可選）

##### Scripts（`scripts/`）

可執行程式碼（Python/Bash 等），用於需要確定性可靠性或反覆重寫的任務。

- **何時包含**：當相同程式碼被反覆重寫，或需要確定性可靠性時
- **範例**：`scripts/rotate_pdf.py` 用於 PDF 旋轉任務
- **好處**：節省 token、確定性、可在不載入上下文的情況下執行
- **注意**：腳本可能仍需 AI 讀取，以進行修補或環境特定調整

##### References（`references/`）

文件和參考資料，依需要載入上下文，以告知 AI 的流程和思考。

- **何時包含**：供 AI 在工作時參考的文件
- **範例**：`references/finance.md` 用於財務結構、`references/mnda.md` 用於公司 NDA 範本、`references/policies.md` 用於公司政策、`references/api_docs.md` 用於 API 規格
- **使用情境**：資料庫結構、API 文件、領域知識、公司政策、詳細工作流程指南
- **好處**：保持 SKILL.md 精簡，只在 AI 判斷需要時載入
- **最佳實踐**：若檔案較大（超過 10k 字），在 SKILL.md 中包含 grep 搜尋模式
- **避免重複**：資訊應存放在 SKILL.md 或 references 檔案中，不應兩者都有。詳細資訊優先放在 references 檔案，除非是技能的核心內容——這樣可保持 SKILL.md 精簡，同時讓資訊可被發現而不佔用上下文視窗。SKILL.md 只保留基本程序說明和工作流程指引；將詳細參考資料、結構和範例移至 references 檔案。

##### Assets（`assets/`）

不打算載入上下文，而是在 AI 產出中使用的檔案。

- **何時包含**：當技能需要在最終輸出中使用的檔案時
- **範例**：`assets/logo.png` 用於品牌資產、`assets/slides.pptx` 用於 PowerPoint 範本、`assets/frontend-template/` 用於 HTML/React 樣板、`assets/font.ttf` 用於字體
- **使用情境**：範本、圖片、圖示、樣板程式碼、字體、被複製或修改的範例文件
- **好處**：將輸出資源與文件分離，讓 AI 無需載入上下文就能使用檔案

#### 技能中不應包含的內容

技能只應包含直接支援其功能的必要檔案。**不要**建立多餘的文件或輔助檔案，包括：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- 等等

技能只應包含 AI 執行任務所需的資訊，不應包含關於建立過程、設定和測試程序、面向使用者的文件等輔助情境。建立額外的文件檔案只會增加雜亂和混淆。

### 漸進式揭露設計原則

技能使用三層載入系統來有效管理上下文：

1. **後設資料（名稱 + 描述）** — 始終在上下文中（約 100 字）
2. **SKILL.md 主體** — 技能觸發時（小於 5k 字）
3. **捆綁資源** — 依 AI 需要載入（無限制，因為腳本可以在不讀入上下文視窗的情況下執行）

#### 漸進式揭露模式

將 SKILL.md 主體保持在必要內容且不超過 500 行，以最小化上下文膨脹。接近此限制時，將內容拆分至獨立檔案。將內容拆分到其他檔案時，必須在 SKILL.md 中引用它們並清楚說明何時讀取，以確保讀者知道它們的存在和使用時機。

**關鍵原則**：當技能支援多種變體、框架或選項時，只在 SKILL.md 中保留核心工作流程和選擇指引。將特定變體的細節（模式、範例、配置）移至獨立的 reference 檔案。

**模式 1：帶參考的高層次指南**

```markdown
# PDF 處理

## 快速開始

用 pdfplumber 提取文字：
[程式碼範例]

## 進階功能

- **填寫表單**：見 [FORMS.md](FORMS.md) 完整指南
- **API 參考**：見 [REFERENCE.md](REFERENCE.md) 所有方法
- **範例**：見 [EXAMPLES.md](EXAMPLES.md) 常見模式
```

AI 只在需要時載入 FORMS.md、REFERENCE.md 或 EXAMPLES.md。

**模式 2：特定領域組織**

對於具有多個領域的技能，按領域組織內容以避免載入不相關的上下文：

```
bigquery-skill/
├── SKILL.md（概覽和導覽）
└── reference/
    ├── finance.md（營收、帳單指標）
    ├── sales.md（商機、管道）
    ├── product.md（API 使用、功能）
    └── marketing.md（行銷活動、歸因）
```

當使用者詢問銷售指標時，AI 只讀取 sales.md。

同樣，對於支援多種框架或變體的技能，按變體組織：

```
cloud-deploy/
├── SKILL.md（工作流程 + 供應商選擇）
└── references/
    ├── aws.md（AWS 部署模式）
    ├── gcp.md（GCP 部署模式）
    └── azure.md（Azure 部署模式）
```

當使用者選擇 AWS 時，AI 只讀取 aws.md。

**模式 3：條件性詳情**

顯示基本內容，連結至進階內容：

```markdown
# DOCX 處理

## 建立文件

使用 docx-js 建立新文件，見 [DOCX-JS.md](DOCX-JS.md)。

## 編輯文件

簡單編輯可直接修改 XML。

**追蹤修訂**：見 [REDLINING.md](REDLINING.md)
**OOXML 詳情**：見 [OOXML.md](OOXML.md)
```

只有在使用者需要那些功能時，AI 才讀取 REDLINING.md 或 OOXML.md。

**重要指引：**

- **避免深層巢狀參考** — 從 SKILL.md 保持一層深度的參考。所有 reference 檔案應直接從 SKILL.md 連結。
- **為較長的 reference 檔案提供結構** — 對於超過 100 行的檔案，在頂部加入目錄，讓 AI 在預覽時就能看到完整範圍。

## 技能建立流程

技能建立包含以下步驟：

1. 用具體案例理解技能
2. 規劃可重複使用的技能內容（腳本、references、assets）
3. 初始化技能（執行 init_skill.py）
4. 編輯技能（實作資源並撰寫 SKILL.md）
5. 封裝技能（執行 package_skill.py）
6. 根據實際使用迭代

按順序執行這些步驟，只有在明確理由說明不適用時才跳過。

### 步驟 1：用具體案例理解技能

只有在技能的使用模式已清楚了解時才跳過此步驟。即使在處理現有技能時，此步驟仍有其價值。

要建立有效的技能，需要清楚了解技能實際使用的具體案例這種理解可以來自使用者提供的案例，或與使用者回饋驗證的生成案例。

例如，建立圖片編輯器技能時，相關問題包括：

- 「圖片編輯器技能應支援什麼功能？編輯、旋轉，還有其他？」
- 「您能舉一些使用此技能的案例嗎？」
- 「我可以想像使用者會問：'幫我去除這張圖的紅眼'或'旋轉這張圖'，您還能想像其他使用方式嗎？」
- 「使用者說什麼應該觸發此技能？」

為避免讓使用者不知所措，避免在單一訊息中問太多問題。從最重要的問題開始，必要時再跟進。

當清楚了解技能應支援的功能時，結束此步驟。

### 步驟 2：規劃可重複使用的技能內容

要將具體案例轉化為有效技能，對每個案例進行分析：

1. 思考如何從頭執行該案例
2. 確認在重複執行這些工作流程時，哪些腳本、references 和 assets 會很有用

範例：建立 `pdf-editor` 技能來處理「幫我旋轉這個 PDF」的需求，分析顯示：

1. 旋轉 PDF 每次都需要重寫相同的程式碼
2. 將 `scripts/rotate_pdf.py` 腳本儲存在技能中會很有用

範例：設計 `frontend-webapp-builder` 技能來處理「幫我建立一個待辦事項應用程式」或「建立一個追蹤步數的儀表板」，分析顯示：

1. 撰寫前端網頁應用程式每次都需要相同的 HTML/React 樣板
2. 將 `assets/hello-world/` 範本（包含 HTML/React 專案樣板檔案）儲存在技能中會很有用

範例：建立 `big-query` 技能來處理「今天有多少使用者登入？」，分析顯示：

1. 查詢 BigQuery 每次都需要重新發現資料表結構和關係
2. 記錄資料表結構的 `references/schema.md` 檔案儲存在技能中會很有用

為建立技能內容，分析每個具體案例以建立要包含的可重複使用資源清單：腳本、references 和 assets。

### 步驟 3：初始化技能

此時需要實際建立技能。

只有在正在開發的技能已存在，且需要迭代或封裝時，才跳過此步驟。此情況下繼續下一步驟。

從頭建立新技能時，務必執行 `init_skill.py` 腳本。此腳本可方便地生成新的範本技能目錄，自動包含技能所需的一切，讓技能建立過程更加高效和可靠。

使用方式：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

此腳本：

- 在指定路徑建立技能目錄
- 生成帶有正確前置資料和 TODO 佔位符的 SKILL.md 範本
- 建立範例資源目錄：`scripts/`、`references/` 和 `assets/`
- 在每個目錄中新增可自訂或刪除的範例檔案

初始化後，根據需要自訂或移除生成的 SKILL.md 和範例檔案。

### 步驟 4：編輯技能

編輯（新生成的或現有的）技能時，記住技能是為另一個 AI 實例使用而建立的。包含對 AI 有益且非顯而易見的資訊。思考哪些程序性知識、特定領域細節或可重複使用的資產，能幫助另一個 AI 實例更有效地執行這些任務。

#### 學習經驗證的設計模式

根據技能需求參閱以下指南：

- **多步驟流程**：見 references/workflows.md，了解順序工作流程和條件邏輯
- **特定輸出格式或品質標準**：見 references/output-patterns.md，了解範本和範例模式

這些檔案包含有效技能設計的既定最佳實踐。

#### 從可重複使用的技能內容開始

開始實作時，從上面確認的可重複使用資源開始：`scripts/`、`references/` 和 `assets/` 檔案。注意此步驟可能需要使用者輸入。例如，實作 `brand-guidelines` 技能時，使用者可能需要提供品牌資產或範本儲存在 `assets/` 中，或文件儲存在 `references/` 中。

新增的腳本必須透過實際執行來測試，確保沒有錯誤且輸出符合預期。若有許多相似的腳本，只需測試具代表性的樣本，以確保所有腳本都能正常運作，同時兼顧完成時間。

不需要的任何範例檔案和目錄應該刪除。初始化腳本在 `scripts/`、`references/` 和 `assets/` 中建立範例檔案以展示結構，但大多數技能不需要全部。

#### 更新 SKILL.md

**撰寫指南**：始終使用命令式 / 不定式形式。

##### 前置資料

用 `name` 和 `description` 撰寫 YAML 前置資料：

- `name`：技能名稱
- `description`：這是技能的主要觸發機制，幫助 AI 了解何時使用此技能。
  - 包含技能的功能和使用的具體觸發條件 / 情境。
  - 在此包含所有「何時使用」的資訊——不要放在主體中。主體只在觸發後才載入，因此主體中的「何時使用此技能」章節對 AI 沒有幫助。
  - `docx` 技能的描述範例："全面的文件建立、編輯和分析，支援追蹤修訂、備註、格式保留和文字提取。當需要處理專業文件（.docx 檔案）時使用：(1) 建立新文件，(2) 修改或編輯內容，(3) 處理追蹤修訂，(4) 新增備註，或任何其他文件任務"

不要在 YAML 前置資料中包含其他欄位。

##### 主體

撰寫使用技能及其捆綁資源的說明。

### 步驟 5：封裝技能

技能開發完成後，必須將其封裝成可分發的 .skill 檔案以與使用者分享。封裝過程會先自動驗證技能，確保符合所有要求：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

可選的輸出目錄指定：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

封裝腳本將：

1. **驗證**技能，自動確認：
   - YAML 前置資料格式和必要欄位
   - 技能命名規範和目錄結構
   - 描述完整性和品質
   - 檔案組織和資源參考

2. **封裝**通過驗證的技能，建立以技能命名的 .skill 檔案（例如 `my-skill.skill`），包含所有檔案並維護適當的目錄結構以供分發。.skill 檔案是帶有 .skill 副檔名的 zip 檔案。

若驗證失敗，腳本將報告錯誤並退出而不建立套件。修正所有驗證錯誤後再次執行封裝指令。

### 步驟 6：迭代

測試技能後，使用者可能要求改進。這通常在使用技能後立即發生，此時對技能表現仍有直觀感受。

**迭代工作流程：**

1. 在真實任務上使用技能
2. 注意遇到的困難或無效率之處
3. 確認 SKILL.md 或捆綁資源應如何更新
4. 實作修改並再次測試
